<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="pt"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>LabelPatternUtil.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">JabRefMain (11 de nov. de 2021 10:55:25)</a> &gt; <a href="../../index.html" class="el_group">JabRef</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">net.sf.jabref.logic.labelpattern</a> &gt; <span class="el_source">LabelPatternUtil.java</span></div><h1>LabelPatternUtil.java</h1><pre class="source lang-java linenums">/*  Copyright (C) 2003-2015 JabRef contributors.
                  2003-2015 Ulrik Stervbo (ulriks AT ruc.dk)

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/
package net.sf.jabref.logic.labelpattern;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.StringTokenizer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import net.sf.jabref.Globals;
import net.sf.jabref.JabRefPreferences;
import net.sf.jabref.MetaData;
import net.sf.jabref.logic.formatter.casechanger.Word;
import net.sf.jabref.logic.layout.format.RemoveLatexCommands;
import net.sf.jabref.logic.util.strings.StringUtil;
import net.sf.jabref.model.database.BibDatabase;
import net.sf.jabref.model.entry.AuthorList;
import net.sf.jabref.model.entry.BibEntry;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;


/**
 * This is the utility class of the LabelPattern package.
 */
<span class="nc" id="L45">public class LabelPatternUtil {</span>

    private static final String STARTING_CAPITAL_PATTERN = &quot;[^A-Z]&quot;;

    // All single characters that we can use for extending a key to make it unique:
    private static final String CHARS = &quot;abcdefghijklmnopqrstuvwxyz&quot;;

<span class="fc" id="L52">    private static final Log LOGGER = LogFactory.getLog(LabelPatternUtil.class);</span>

<span class="fc" id="L54">    private static final Pattern REGEX_PATTERN = Pattern.compile(&quot;.*\\(\\{([A-Z]+)\\}\\).*&quot;);</span>

    private static List&lt;String&gt; defaultLabelPattern;

    private static final int CHARS_OF_FIRST = 5;


    static {
<span class="fc" id="L62">        updateDefaultPattern();</span>
    }

<span class="fc" id="L65">    private static BibDatabase database;</span>

    public static void updateDefaultPattern() {
<span class="fc" id="L68">        defaultLabelPattern = LabelPatternUtil</span>
<span class="fc" id="L69">                .split(JabRefPreferences.getInstance().get(JabRefPreferences.DEFAULT_LABEL_PATTERN));</span>
<span class="fc" id="L70">    }</span>

    /**
     * Required for LabelPatternUtilTest
     *
     * @param db the DB to use as global database
     */
    public static void setDataBase(BibDatabase db) {
<span class="nc" id="L78">        database = db;</span>
<span class="nc" id="L79">    }</span>

    private static String normalize(String content) {
<span class="nc" id="L82">        List&lt;String&gt; tokens = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L83">        int b = 0;</span>
<span class="nc" id="L84">        StringBuilder and = new StringBuilder();</span>
<span class="nc" id="L85">        StringBuilder token = new StringBuilder();</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">        for (int p = 0; p &lt; content.length(); p++) {</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">            if (b == 0) {</span>
<span class="nc" id="L88">                String andString = and.toString(); // Avoid lots of calls</span>
<span class="nc bnc" id="L89" title="All 4 branches missed.">                if (((andString.isEmpty()) &amp;&amp; (content.charAt(p) == ' '))</span>
<span class="nc bnc" id="L90" title="All 4 branches missed.">                        || (&quot; &quot;.equals(andString) &amp;&amp; (content.charAt(p) == 'a'))</span>
<span class="nc bnc" id="L91" title="All 4 branches missed.">                        || (&quot; a&quot;.equals(andString) &amp;&amp; (content.charAt(p) == 'n'))</span>
<span class="nc bnc" id="L92" title="All 4 branches missed.">                        || (&quot; an&quot;.equals(andString) &amp;&amp; (content.charAt(p) == 'd'))) {</span>
<span class="nc" id="L93">                    and.append(content.charAt(p));</span>
<span class="nc bnc" id="L94" title="All 4 branches missed.">                } else if (&quot; and&quot;.equals(and.toString()) &amp;&amp; (content.charAt(p) == ' ')) {</span>
<span class="nc" id="L95">                    and = new StringBuilder();</span>
<span class="nc" id="L96">                    tokens.add(token.toString().trim());</span>
<span class="nc" id="L97">                    token = new StringBuilder();</span>
<span class="nc" id="L98">                } else {</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">                    if (content.charAt(p) == '{') {</span>
<span class="nc" id="L100">                        b++;</span>
                    }
<span class="nc bnc" id="L102" title="All 2 branches missed.">                    if (content.charAt(p) == '}') {</span>
<span class="nc" id="L103">                        b--;</span>
                    }
<span class="nc" id="L105">                    token.append(and);</span>
<span class="nc" id="L106">                    and = new StringBuilder();</span>
<span class="nc" id="L107">                    token.append(content.charAt(p));</span>
                }
<span class="nc" id="L109">            } else {</span>
<span class="nc" id="L110">                token.append(content.charAt(p));</span>
            }
        }
<span class="nc" id="L113">        tokens.add(token.toString());</span>
<span class="nc" id="L114">        StringBuilder normalized = new StringBuilder(&quot;&quot;);</span>

<span class="nc bnc" id="L116" title="All 2 branches missed.">        for (int i = 0; i &lt; tokens.size(); i++) {</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">            if (i &gt; 0) {</span>
<span class="nc" id="L118">                normalized.append(&quot; and &quot;);</span>
            }

<span class="nc bnc" id="L121" title="All 2 branches missed.">            normalized.append(isInstitution(tokens.get(i)) ? generateInstitutionKey(tokens.get(i)) : removeDiacritics(</span>
<span class="nc" id="L122">                    tokens.get(i)));</span>
        }
<span class="nc" id="L124">        return normalized.toString();</span>
    }

    /**
     * Will remove diacritics from the content.
     *
     * Replaces umlaut: \&quot;x with xe, e.g. \&quot;o -&gt; oe, \&quot;u -&gt; ue, etc.
     * Removes all other diacritics: \?x -&gt; x, e.g. \'a -&gt; a, etc.
     *
     * @param content The content.
     * @return The content without diacritics.
     */
    private static String removeDiacritics(String content) {
<span class="nc bnc" id="L137" title="All 2 branches missed.">        if (content.isEmpty()) {</span>
<span class="nc" id="L138">            return content;</span>
        }

<span class="nc" id="L141">        String result = content;</span>
        // Replace umlaut with '?e'
<span class="nc" id="L143">        result = result.replaceAll(&quot;\\{\\\\\&quot;([a-zA-Z])\\}&quot;, &quot;$1e&quot;);</span>
<span class="nc" id="L144">        result = result.replaceAll(&quot;\\\\\&quot;\\{([a-zA-Z])\\}&quot;, &quot;$1e&quot;);</span>
<span class="nc" id="L145">        result = result.replaceAll(&quot;\\\\\&quot;([a-zA-Z])&quot;, &quot;$1e&quot;);</span>
        // Remove diacritics
<span class="nc" id="L147">        result = result.replaceAll(&quot;\\{\\\\.([a-zA-Z])\\}&quot;, &quot;$1&quot;);</span>
<span class="nc" id="L148">        result = result.replaceAll(&quot;\\\\.\\{([a-zA-Z])\\}&quot;, &quot;$1&quot;);</span>
<span class="nc" id="L149">        result = result.replaceAll(&quot;\\\\.([a-zA-Z])&quot;, &quot;$1&quot;);</span>
<span class="nc" id="L150">        return result;</span>
    }

    /**
     * Unifies umlauts.
     *
     * Replaces: $\ddot{\mathrm{X}}$ (an alternative umlaut) with: {\&quot;X}
     * Replaces: \?{X} and \?X with {\?X}, where ? is a diacritic symbol
     *
     * @param content The content.
     * @return The content with unified diacritics.
     */
    private static String unifyDiacritics(String content) {
<span class="nc" id="L163">        return content.replaceAll(</span>
<span class="nc" id="L164">                &quot;\\$\\\\ddot\\{\\\\mathrm\\{([^\\}])\\}\\}\\$&quot;,</span>
<span class="nc" id="L165">                &quot;{\\\&quot;$1}&quot;).replaceAll(</span>
<span class="nc" id="L166">                &quot;(\\\\[^\\-a-zA-Z])\\{?([a-zA-Z])\\}?&quot;,</span>
<span class="nc" id="L167">                &quot;{$1$2}&quot;);</span>
    }

    /**
     * Check if a value is institution.
     *
     * This is usable for distinguishing between persons and institutions in
     * the author or editor fields.
     *
     * A person:
     *   - &quot;John Doe&quot;
     *   - &quot;Doe, John&quot;
     *
     * An institution:
     *   - &quot;{The Big Company or Institution Inc.}&quot;
     *   - &quot;{The Big Company or Institution Inc. (BCI)}&quot;
     *
     * @param author Author or editor.
     * @return True if the author or editor is an institution.
     */
    private static boolean isInstitution(String author) {
<span class="nc" id="L188">        return StringUtil.isInCurlyBrackets(author);</span>
    }

    /**
     * &lt;p&gt;
     * An author or editor may be and institution not a person. In that case the
     * key generator builds very long keys, e.g.: for &amp;ldquo;The Attributed
     * Graph Grammar System (AGG)&amp;rdquo; -&gt;
     * &amp;ldquo;TheAttributedGraphGrammarSystemAGG&amp;rdquo;.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * An institution name should be inside &lt;code&gt;{}&lt;/code&gt; brackets. If the
     * institution name also includes its abbreviation this abbreviation should
     * be also in &lt;code&gt;{}&lt;/code&gt; brackets. For the previous example the value
     * should look like:
     * &lt;code&gt;{The Attributed Graph Grammar System ({AGG})}&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If an institution includes its abbreviation, i.e. &quot;...({XYZ})&quot;, first
     * such abbreviation should be used as the key value part of such author.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If an institution does not include its abbreviation the key should be
     * generated form its name in the following way:
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * The institution value can contain: institution name, part of the
     * institution, address, etc. Those information should be separated by
     * comma. Name of the institution and possible part of the institution
     * should be on the beginning, while address and secondary information
     * should be on the end.
     * &lt;/p&gt;
     *
     * Each part is examined separately:
     * &lt;ol&gt;
     * &lt;li&gt;We remove all tokens of a part which are one of the defined ignore
     * words (the, press), which end with a dot (ltd., co., ...) and which first
     * character is lowercase (of, on, di, ...).&lt;/li&gt;
     * &lt;li&gt;We detect a type of the part: university, technology institute,
     * department, school, rest
     * &lt;ul&gt;
     * &lt;li&gt;University: &lt;code&gt;&quot;Uni[NameOfTheUniversity]&quot;&lt;/code&gt;&lt;/li&gt;
     * &lt;li&gt;Department: will be an abbreviation of all words beginning with the
     * uppercase letter except of words: &lt;code&gt;d[ei]p.*&lt;/code&gt;, school,
     * faculty&lt;/li&gt;
     * &lt;li&gt;School: same as department&lt;/li&gt;
     * &lt;li&gt;Rest: If there are less than 3 tokens in such part than the result
     * will be by concatenating those tokens, otherwise the result will be build
     * from the first letters of words starting with and uppercase letter.&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;/ol&gt;
     *
     * Parts are concatenated together in the following way:
     * &lt;ul&gt;
     * &lt;li&gt;If there is a university part use it otherwise use the rest part.&lt;/li&gt;
     * &lt;li&gt;If there is a school part append it.&lt;/li&gt;
     * &lt;li&gt;If there is a department part and it is not same as school part
     * append it.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * Rest part is only the first part which do not match any other type. All
     * other parts (address, ...) are ignored.
     *
     * @param content the institution to generate a Bibtex key for
     * @return &lt;ul&gt;
     *         &lt;li&gt;the institution key&lt;/li&gt;
     *         &lt;li&gt;&quot;&quot; in the case of a failure&lt;/li&gt;
     *         &lt;li&gt;null if content is null&lt;/li&gt;
     *         &lt;/ul&gt;
     */
    private static String generateInstitutionKey(String content) {
<span class="nc bnc" id="L263" title="All 2 branches missed.">        if (content.isEmpty()) {</span>
<span class="nc" id="L264">            return content;</span>
        }

<span class="nc" id="L267">        String result = content;</span>
<span class="nc" id="L268">        result = unifyDiacritics(result);</span>
<span class="nc" id="L269">        result = result.replaceAll(&quot;^\\{&quot;, &quot;&quot;).replaceAll(&quot;\\}$&quot;, &quot;&quot;);</span>
<span class="nc" id="L270">        Matcher matcher = REGEX_PATTERN.matcher(result);</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L272">            return matcher.group(1);</span>
        }

<span class="nc" id="L275">        result = removeDiacritics(result);</span>
<span class="nc" id="L276">        String[] parts = result.split(&quot;,&quot;);</span>

        // Key parts
<span class="nc" id="L279">        String university = null;</span>
<span class="nc" id="L280">        String department = null;</span>
<span class="nc" id="L281">        String school = null;</span>
<span class="nc" id="L282">        String rest = null;</span>

<span class="nc" id="L284">        List&lt;String&gt; ignore = Arrays.asList(&quot;press&quot;, &quot;the&quot;);</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">        for (int index = 0; index &lt; parts.length; index++) {</span>
<span class="nc" id="L286">            List&lt;String&gt; part = new ArrayList&lt;&gt;();</span>

            // Cleanup: remove unnecessary words.
<span class="nc bnc" id="L289" title="All 2 branches missed.">            for (String k : parts[index].replaceAll(&quot;\\{[A-Z]+\\}&quot;, &quot;&quot;).split(&quot;[ \\-_]&quot;)) {</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">                if ((!(k.isEmpty()) // remove empty</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">                        &amp;&amp; !ignore.contains(k.toLowerCase()) // remove ignored words</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">                        &amp;&amp; (k.charAt(k.length() - 1) != '.')</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">                        &amp;&amp; (String.valueOf(k.charAt(0))).matches(&quot;[A-Z]&quot;))</span>
<span class="nc bnc" id="L294" title="All 4 branches missed.">                        || ((k.length() &gt;= 3) &amp;&amp; &quot;uni&quot;.equalsIgnoreCase(k.substring(0, 2)))) {</span>
<span class="nc" id="L295">                    part.add(k);</span>
                }
            }

<span class="nc" id="L299">            boolean isUniversity = false; // university</span>
<span class="nc" id="L300">            boolean isTechnology = false; // technology institute</span>
<span class="nc" id="L301">            boolean isDepartment = false; // departments</span>
<span class="nc" id="L302">            boolean isSchool = false; // schools</span>

            // Deciding about a part type...
<span class="nc bnc" id="L305" title="All 2 branches missed.">            for (String k : part) {</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">                if (k.matches(&quot;^[Uu][Nn][Ii].*&quot;)) { // Starts with &quot;uni&quot; case and locale independent</span>
<span class="nc" id="L307">                    isUniversity = true;</span>
                }
<span class="nc bnc" id="L309" title="All 2 branches missed.">                if (k.matches(&quot;^[Tt][Ee][Cc][Hh].*&quot;)) { // Starts with &quot;tech&quot; case and locale independent</span>
<span class="nc" id="L310">                    isTechnology = true;</span>
                }
<span class="nc bnc" id="L312" title="All 2 branches missed.">                if (&quot;school&quot;.equalsIgnoreCase(k)) {</span>
<span class="nc" id="L313">                    isSchool = true;</span>
                }
<span class="nc bnc" id="L315" title="All 4 branches missed.">                if (k.matches(&quot;^[Dd][EeIi][Pp].*&quot;) || k.matches(&quot;^[Ll][Aa][Bb].*&quot;)) { // Starts with &quot;dep&quot;/&quot;dip&quot;/&quot;lab&quot;, case and locale independent</span>
<span class="nc" id="L316">                    isDepartment = true;</span>
                }
            }
<span class="nc bnc" id="L319" title="All 2 branches missed.">            if (isTechnology) {</span>
<span class="nc" id="L320">                isUniversity = false; // technology institute isn't university :-)</span>
            }

            // University part looks like: Uni[NameOfTheUniversity]
            //
            // If university is detected than the previous part is suggested
            // as department
<span class="nc bnc" id="L327" title="All 2 branches missed.">            if (isUniversity) {</span>
<span class="nc" id="L328">                StringBuilder universitySB = new StringBuilder();</span>
<span class="nc" id="L329">                universitySB.append(&quot;Uni&quot;);</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">                for (String k : part) {</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">                    if (!k.matches(&quot;^[Uu][Nn][Ii].*&quot;)) {</span>
<span class="nc" id="L332">                        universitySB.append(k);</span>
                    }
                }
<span class="nc" id="L335">                university = universitySB.toString();</span>
<span class="nc bnc" id="L336" title="All 4 branches missed.">                if ((index &gt; 0) &amp;&amp; (department == null)) {</span>
<span class="nc" id="L337">                    department = parts[index - 1];</span>
                }

                // School is an abbreviation of all the words beginning with a
                // capital letter excluding: department, school and faculty words.
                //
                // Explicitly defined department part is build the same way as
                // school
<span class="nc bnc" id="L345" title="All 4 branches missed.">            } else if (isSchool || isDepartment) {</span>
<span class="nc" id="L346">                StringBuilder schoolSB = new StringBuilder();</span>
<span class="nc" id="L347">                StringBuilder departmentSB = new StringBuilder();</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">                for (String k : part) {</span>
<span class="nc bnc" id="L349" title="All 4 branches missed.">                    if (!k.matches(&quot;^[Dd][EeIi][Pp].*&quot;) &amp;&amp; !&quot;school&quot;.equalsIgnoreCase(k)</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">                            &amp;&amp; !&quot;faculty&quot;.equalsIgnoreCase(k)</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">                            &amp;&amp; !(k.replaceAll(STARTING_CAPITAL_PATTERN, &quot;&quot;).isEmpty())) {</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">                        if (isSchool) {</span>
<span class="nc" id="L353">                            schoolSB.append(k.replaceAll(STARTING_CAPITAL_PATTERN, &quot;&quot;));</span>
                        }
<span class="nc bnc" id="L355" title="All 2 branches missed.">                        if (isDepartment) {</span>
<span class="nc" id="L356">                            departmentSB.append(k.replaceAll(STARTING_CAPITAL_PATTERN, &quot;&quot;));</span>
                        }
                    }
                }
<span class="nc bnc" id="L360" title="All 2 branches missed.">                if (isSchool) {</span>
<span class="nc" id="L361">                    school = schoolSB.toString();</span>
                }
<span class="nc bnc" id="L363" title="All 2 branches missed.">                if (isDepartment) {</span>
<span class="nc" id="L364">                    department = departmentSB.toString();</span>
                }
                // A part not matching university, department nor school.
<span class="nc bnc" id="L367" title="All 2 branches missed.">            } else if (rest == null) {</span>
<span class="nc" id="L368">                StringBuilder restSB = new StringBuilder();</span>
                // Less than 3 parts -&gt; concatenate those
<span class="nc bnc" id="L370" title="All 2 branches missed.">                if (part.size() &lt; 3) {</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">                    for (String k : part) {</span>
<span class="nc" id="L372">                        restSB.append(k);</span>
                    // More than 3 parts -&gt; use 1st letter abbreviation
                    }
<span class="nc" id="L375">                } else {</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">                    for (String k : part) {</span>
<span class="nc" id="L377">                        k = k.replaceAll(STARTING_CAPITAL_PATTERN, &quot;&quot;);</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">                        if (!(k.isEmpty())) {</span>
<span class="nc" id="L379">                            restSB.append(k);</span>
                        }
                    }
                }
<span class="nc" id="L383">                rest = restSB.toString();</span>
            }
        }

        // Putting parts together.
<span class="nc bnc" id="L388" title="All 2 branches missed.">        return (university == null ? rest : university)</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">                + (school == null ? &quot;&quot; : school)</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">                + ((department == null)</span>
<span class="nc bnc" id="L391" title="All 4 branches missed.">                || ((school != null) &amp;&amp; department.equals(school)) ?</span>
<span class="nc" id="L392">                        &quot;&quot; : department);</span>
    }

    /**
     * This method takes a string of the form [field1]spacer[field2]spacer[field3]...,
     * where the fields are the (required) fields of a BibTex entry. The string is split
     * into fields and spacers by recognizing the [ and ].
     *
     * @param labelPattern a &lt;code&gt;String&lt;/code&gt;
     * @return an &lt;code&gt;ArrayList&lt;/code&gt; The first item of the list
     * is a string representation of the key pattern (the parameter),
     * the remaining items are the fields
     */
    public static List&lt;String&gt; split(String labelPattern) {
        // A holder for fields of the entry to be used for the key
<span class="fc" id="L407">        List&lt;String&gt; fieldList = new ArrayList&lt;&gt;();</span>

        // Before we do anything, we add the parameter to the ArrayLIst
<span class="fc" id="L410">        fieldList.add(labelPattern);</span>

<span class="fc" id="L412">        StringTokenizer tok = new StringTokenizer(labelPattern, &quot;[]&quot;, true);</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">        while (tok.hasMoreTokens()) {</span>
<span class="fc" id="L414">            fieldList.add(tok.nextToken());</span>
        }
<span class="fc" id="L416">        return fieldList;</span>
    }

    /**
     * Generates a BibTeX label according to the pattern for a given entry type, and saves the unique label in the
     * &lt;code&gt;Bibtexentry&lt;/code&gt;.
     *
     * The given database is used to avoid duplicate keys.
     *
     * @param dBase a &lt;code&gt;BibDatabase&lt;/code&gt;
     * @param entry a &lt;code&gt;BibEntry&lt;/code&gt;
     * @return modified BibEntry
     */
    public static void makeLabel(MetaData metaData, BibDatabase dBase, BibEntry entry) {
<span class="nc" id="L430">        database = dBase;</span>
        String key;
<span class="nc" id="L432">        StringBuilder stringBuilder = new StringBuilder();</span>
<span class="nc" id="L433">        boolean forceUpper = false;</span>
<span class="nc" id="L434">        boolean forceLower = false;</span>

        try {
            // get the type of entry
<span class="nc" id="L438">            String entryType = entry.getType();</span>
            // Get the arrayList corresponding to the type
<span class="nc" id="L440">            List&lt;String&gt; typeList = new ArrayList&lt;&gt;(metaData.getLabelPattern().getValue(entryType));</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">            if (!typeList.isEmpty()) {</span>
<span class="nc" id="L442">                typeList.remove(0);</span>
            }
<span class="nc" id="L444">            boolean field = false;</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">            for (String typeListEntry : typeList) {</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">                if (&quot;[&quot;.equals(typeListEntry)) {</span>
<span class="nc" id="L447">                    field = true;</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">                } else if (&quot;]&quot;.equals(typeListEntry)) {</span>
<span class="nc" id="L449">                    field = false;</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">                } else if (field) {</span>
                    // check whether there is a modifier on the end such as
                    // &quot;:lower&quot;
<span class="nc" id="L453">                    String[] parts = parseFieldMarker(typeListEntry);</span>

<span class="nc" id="L455">                    String label = makeLabel(entry, parts[0]);</span>

                    // apply modifier if present
<span class="nc bnc" id="L458" title="All 2 branches missed.">                    if (parts.length &gt; 1) {</span>
<span class="nc" id="L459">                        label = applyModifiers(label, parts, 1);</span>
                    }

<span class="nc" id="L462">                    stringBuilder.append(label);</span>

<span class="nc" id="L464">                } else {</span>
<span class="nc" id="L465">                    stringBuilder.append(typeListEntry);</span>
                }
            }
<span class="nc" id="L468">        } catch (Exception e) {</span>
<span class="nc" id="L469">            LOGGER.warn(&quot;Cannot make label&quot;, e);</span>
        }

        // Remove all illegal characters from the key.
<span class="nc" id="L473">        key = checkLegalKey(stringBuilder.toString());</span>

        // Remove Regular Expressions while generating Keys
<span class="nc" id="L476">        String regex = Globals.prefs.get(JabRefPreferences.KEY_PATTERN_REGEX);</span>
<span class="nc bnc" id="L477" title="All 4 branches missed.">        if ((regex != null) &amp;&amp; !regex.trim().isEmpty()) {</span>
<span class="nc" id="L478">            String replacement = Globals.prefs.get(JabRefPreferences.KEY_PATTERN_REPLACEMENT);</span>
<span class="nc" id="L479">            key = key.replaceAll(regex, replacement);</span>
        }

<span class="nc bnc" id="L482" title="All 2 branches missed.">        if (forceUpper) {</span>
<span class="nc" id="L483">            key = key.toUpperCase();</span>
        }
<span class="nc bnc" id="L485" title="All 2 branches missed.">        if (forceLower) {</span>
<span class="nc" id="L486">            key = key.toLowerCase();</span>
        }

<span class="nc" id="L489">        String oldKey = entry.getCiteKey();</span>
<span class="nc" id="L490">        int occurrences = database.getNumberOfKeyOccurrences(key);</span>

<span class="nc bnc" id="L492" title="All 4 branches missed.">        if ((oldKey != null) &amp;&amp; oldKey.equals(key)) {</span>
<span class="nc" id="L493">            occurrences--; // No change, so we can accept one dupe.</span>
        }

<span class="nc" id="L496">        boolean alwaysAddLetter = Globals.prefs.getBoolean(JabRefPreferences.KEY_GEN_ALWAYS_ADD_LETTER);</span>
<span class="nc" id="L497">        boolean firstLetterA = Globals.prefs.getBoolean(JabRefPreferences.KEY_GEN_FIRST_LETTER_A);</span>

<span class="nc bnc" id="L499" title="All 4 branches missed.">        if (!alwaysAddLetter &amp;&amp; (occurrences == 0)) {</span>
            // No dupes found, so we can just go ahead.
<span class="nc bnc" id="L501" title="All 2 branches missed.">            if (!key.equals(oldKey)) {</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">                if (!database.containsEntryWithId(entry.getId())) {</span>
                    // entry does not (yet) exist in the database, just update the entry
<span class="nc" id="L504">                    entry.setCiteKey(key);</span>
<span class="nc" id="L505">                } else {</span>
<span class="nc" id="L506">                    database.setCiteKeyForEntry(entry, key);</span>
                }
            }

<span class="nc" id="L510">        } else {</span>
            // The key is already in use, so we must modify it.
<span class="nc" id="L512">            int number = 0;</span>
<span class="nc bnc" id="L513" title="All 4 branches missed.">            if (!alwaysAddLetter &amp;&amp; !firstLetterA) {</span>
<span class="nc" id="L514">                number = 1;</span>
            }

<span class="nc" id="L517">            String moddedKey = key + getAddition(number);</span>
<span class="nc" id="L518">            occurrences = database.getNumberOfKeyOccurrences(moddedKey);</span>

<span class="nc bnc" id="L520" title="All 4 branches missed.">            if ((oldKey != null) &amp;&amp; oldKey.equals(moddedKey)) {</span>
<span class="nc" id="L521">                occurrences--;</span>
            }

<span class="nc bnc" id="L524" title="All 2 branches missed.">            while (occurrences &gt; 0) {</span>
<span class="nc" id="L525">                number++;</span>
<span class="nc" id="L526">                moddedKey = key + getAddition(number);</span>

<span class="nc" id="L528">                occurrences = database.getNumberOfKeyOccurrences(moddedKey);</span>
<span class="nc bnc" id="L529" title="All 4 branches missed.">                if ((oldKey != null) &amp;&amp; oldKey.equals(moddedKey)) {</span>
<span class="nc" id="L530">                    occurrences--;</span>
                }
            }

<span class="nc bnc" id="L534" title="All 2 branches missed.">            if (!moddedKey.equals(oldKey)) {</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">                if (!database.containsEntryWithId(entry.getId())) {</span>
                    // entry does not (yet) exist in the database, just update the entry
<span class="nc" id="L537">                    entry.setCiteKey(moddedKey);</span>
<span class="nc" id="L538">                } else {</span>
<span class="nc" id="L539">                    database.setCiteKeyForEntry(entry, moddedKey);</span>
                }
            }
        }
<span class="nc" id="L543">    }</span>

    /**
     * Applies modifiers to a label generated based on a field marker.
     * @param label The generated label.
     * @param parts String array containing the modifiers.
     * @param offset The number of initial items in the modifiers array to skip.
     * @return The modified label.
     */
    public static String applyModifiers(String label, String[] parts, int offset) {
<span class="nc" id="L553">        String resultingLabel = label;</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">        if (parts.length &gt; offset) {</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">            for (int j = offset; j &lt; parts.length; j++) {</span>
<span class="nc" id="L556">                String modifier = parts[j];</span>

<span class="nc bnc" id="L558" title="All 2 branches missed.">                if (&quot;lower&quot;.equals(modifier)) {</span>
<span class="nc" id="L559">                    resultingLabel = resultingLabel.toLowerCase();</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">                } else if (&quot;upper&quot;.equals(modifier)) {</span>
<span class="nc" id="L561">                    resultingLabel = resultingLabel.toUpperCase();</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">                } else if (&quot;abbr&quot;.equals(modifier)) {</span>
                    // Abbreviate - that is,
<span class="nc" id="L564">                    StringBuilder abbreviateSB = new StringBuilder();</span>
<span class="nc" id="L565">                    String[] words = resultingLabel.replaceAll(&quot;[\\{\\}']&quot;, &quot;&quot;)</span>
<span class="nc" id="L566">                            .split(&quot;[\\(\\) \r\n\&quot;]&quot;);</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">                    for (String word1 : words) {</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">                        if (!word1.isEmpty()) {</span>
<span class="nc" id="L569">                            abbreviateSB.append(word1.charAt(0));</span>
                        }
                    }
<span class="nc" id="L572">                    resultingLabel = abbreviateSB.toString();</span>

<span class="nc bnc" id="L574" title="All 6 branches missed.">                } else if (!modifier.isEmpty() &amp;&amp; (modifier.charAt(0) == '(') &amp;&amp; modifier.endsWith(&quot;)&quot;)) {</span>
                    // Alternate text modifier in parentheses. Should be inserted if
                    // the label is empty:
<span class="nc bnc" id="L577" title="All 4 branches missed.">                    if (resultingLabel.isEmpty() &amp;&amp; (modifier.length() &gt; 2)) {</span>
<span class="nc" id="L578">                        return modifier.substring(1, modifier.length() - 1);</span>
                    }

                } else {
<span class="nc" id="L582">                    LOGGER.info(&quot;Key generator warning: unknown modifier '&quot;</span>
<span class="nc" id="L583">                            + modifier + &quot;'.&quot;);</span>
                }
            }
        }
<span class="nc" id="L587">        return resultingLabel;</span>
    }

    public static String makeLabel(BibEntry entry, String value) {
<span class="nc" id="L591">        String val = value;</span>
        try {
<span class="nc bnc" id="L593" title="All 4 branches missed.">            if (val.startsWith(&quot;auth&quot;) || val.startsWith(&quot;pureauth&quot;)) {</span>

                /*
                 * For label code &quot;auth...&quot;: if there is no author, but there
                 * are editor(s) (e.g. for an Edited Book), use the editor(s)
                 * instead. (saw27@mrao.cam.ac.uk). This is what most people
                 * want, but in case somebody really needs a field which expands
                 * to nothing if there is no author (e.g. someone who uses both
                 * &quot;auth&quot; and &quot;ed&quot; in the same label), we provide an alternative
                 * form &quot;pureauth...&quot; which does not do this fallback
                 * substitution of editor.
                 */
<span class="nc" id="L605">                String authString = entry.getField(&quot;author&quot;);</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">                if (authString != null) {</span>
<span class="nc" id="L607">                    authString = normalize(database.resolveForStrings(authString));</span>
                }

<span class="nc bnc" id="L610" title="All 2 branches missed.">                if (val.startsWith(&quot;pure&quot;)) {</span>
                    // remove the &quot;pure&quot; prefix so the remaining
                    // code in this section functions correctly
<span class="nc" id="L613">                    val = val.substring(4);</span>
                }

<span class="nc bnc" id="L616" title="All 4 branches missed.">                if ((authString == null) || authString.isEmpty()) {</span>
<span class="nc" id="L617">                    authString = entry.getField(&quot;editor&quot;);</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">                    if (authString == null) {</span>
<span class="nc" id="L619">                        authString = &quot;&quot;;</span>
<span class="nc" id="L620">                    } else {</span>
<span class="nc" id="L621">                        authString = normalize(database.resolveForStrings(authString));</span>
                    }
                }

                // Gather all author-related checks, so we don't
                // have to check all the time.
<span class="nc bnc" id="L627" title="All 2 branches missed.">                if (&quot;auth&quot;.equals(val)) {</span>
<span class="nc" id="L628">                    return firstAuthor(authString);</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">                } else if (&quot;authForeIni&quot;.equals(val)) {</span>
<span class="nc" id="L630">                    return firstAuthorForenameInitials(authString);</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">                } else if (&quot;authFirstFull&quot;.equals(val)) {</span>
<span class="nc" id="L632">                    return firstAuthorVonAndLast(authString);</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">                } else if (&quot;authors&quot;.equals(val)) {</span>
<span class="nc" id="L634">                    return allAuthors(authString);</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">                } else if (&quot;authorsAlpha&quot;.equals(val)) {</span>
<span class="nc" id="L636">                    return authorsAlpha(authString);</span>
                }
                // Last author's last name
<span class="nc bnc" id="L639" title="All 2 branches missed.">                else if (&quot;authorLast&quot;.equals(val)) {</span>
<span class="nc" id="L640">                    return lastAuthor(authString);</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">                } else if (&quot;authorLastForeIni&quot;.equals(val)) {</span>
<span class="nc" id="L642">                    return lastAuthorForenameInitials(authString);</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">                } else if (&quot;authorIni&quot;.equals(val)) {</span>
<span class="nc" id="L644">                    return oneAuthorPlusIni(authString);</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">                } else if (val.matches(&quot;authIni[\\d]+&quot;)) {</span>
<span class="nc" id="L646">                    int num = Integer.parseInt(val.substring(7));</span>
<span class="nc" id="L647">                    String s = authIniN(authString, num);</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">                    return s == null ? &quot;&quot; : s;</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">                } else if (&quot;auth.auth.ea&quot;.equals(val)) {</span>
<span class="nc" id="L650">                    String s = authAuthEa(authString);</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">                    return s == null ? &quot;&quot; : s;</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">                } else if (&quot;auth.etal&quot;.equals(val)) {</span>
<span class="nc" id="L653">                    String s = authEtal(authString, &quot;.&quot;, &quot;.etal&quot;);</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">                    return s == null ? &quot;&quot; : s;</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">                } else if (&quot;authEtAl&quot;.equals(val)) {</span>
<span class="nc" id="L656">                    String s = authEtal(authString, &quot;&quot;, &quot;EtAl&quot;);</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">                    return s == null ? &quot;&quot; : s;</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">                } else if (&quot;authshort&quot;.equals(val)) {</span>
<span class="nc" id="L659">                    String s = authshort(authString);</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">                    return s == null ? &quot;&quot; : s;</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">                } else if (val.matches(&quot;auth[\\d]+_[\\d]+&quot;)) {</span>
<span class="nc" id="L662">                    String[] nums = val.substring(4).split(&quot;_&quot;);</span>
<span class="nc" id="L663">                    String s = authNofMth(authString, Integer.parseInt(nums[0]),</span>
<span class="nc" id="L664">                            Integer.parseInt(nums[1]));</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">                    return s == null ? &quot;&quot; : s;</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">                } else if (val.matches(&quot;auth\\d+&quot;)) {</span>
                    // authN. First N chars of the first author's last
                    // name.

<span class="nc" id="L670">                    String fa = firstAuthor(authString);</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">                    if (fa == null) {</span>
<span class="nc" id="L672">                        return &quot;&quot;;</span>
                    }
<span class="nc" id="L674">                    int num = Integer.parseInt(val.substring(4));</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">                    if (num &gt; fa.length()) {</span>
<span class="nc" id="L676">                        num = fa.length();</span>
                    }
<span class="nc" id="L678">                    return fa.substring(0, num);</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">                } else if (val.matches(&quot;authors\\d+&quot;)) {</span>
<span class="nc" id="L680">                    String s = nAuthors(authString, Integer.parseInt(val.substring(7)));</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">                    return s == null ? &quot;&quot; : s;</span>
                } else {
                    // This &quot;auth&quot; business was a dead end, so just
                    // use it literally:
<span class="nc" id="L685">                    return getField(entry, val);</span>
                }
<span class="nc bnc" id="L687" title="All 2 branches missed.">            } else if (val.startsWith(&quot;ed&quot;)) {</span>
                // Gather all markers starting with &quot;ed&quot; here, so we
                // don't have to check all the time.
<span class="nc bnc" id="L690" title="All 2 branches missed.">                if (&quot;edtr&quot;.equals(val)) {</span>
<span class="nc" id="L691">                    return firstAuthor(entry.getField(&quot;editor&quot;));</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">                } else if (&quot;edtrForeIni&quot;.equals(val)) {</span>
<span class="nc" id="L693">                    return firstAuthorForenameInitials(entry.getField(&quot;editor&quot;));</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">                } else if (&quot;editors&quot;.equals(val)) {</span>
<span class="nc" id="L695">                    return allAuthors(entry.getField(&quot;editor&quot;));</span>
                    // Last author's last name
<span class="nc bnc" id="L697" title="All 2 branches missed.">                } else if (&quot;editorLast&quot;.equals(val)) {</span>
<span class="nc" id="L698">                    return lastAuthor(entry.getField(&quot;editor&quot;));</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">                } else if (&quot;editorLastForeIni&quot;.equals(val)) {</span>
<span class="nc" id="L700">                    return lastAuthorForenameInitials(entry.getField(&quot;editor&quot;));</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">                } else if (&quot;editorIni&quot;.equals(val)) {</span>
<span class="nc" id="L702">                    return oneAuthorPlusIni(entry.getField(&quot;editor&quot;));</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">                } else if (val.matches(&quot;edtrIni[\\d]+&quot;)) {</span>
<span class="nc" id="L704">                    int num = Integer.parseInt(val.substring(7));</span>
<span class="nc" id="L705">                    String s = authIniN(entry.getField(&quot;editor&quot;), num);</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">                    return s == null ? &quot;&quot; : s;</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">                } else if (val.matches(&quot;edtr[\\d]+_[\\d]+&quot;)) {</span>
<span class="nc" id="L708">                    String[] nums = val.substring(4).split(&quot;_&quot;);</span>
<span class="nc" id="L709">                    String s = authNofMth(entry.getField(&quot;editor&quot;),</span>
<span class="nc" id="L710">                            Integer.parseInt(nums[0]),</span>
<span class="nc" id="L711">                            Integer.parseInt(nums[1]) - 1);</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">                    return s == null ? &quot;&quot; : s;</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">                } else if (&quot;edtr.edtr.ea&quot;.equals(val)) {</span>
<span class="nc" id="L714">                    String s = authAuthEa(entry.getField(&quot;editor&quot;));</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">                    return s == null ? &quot;&quot; : s;</span>
<span class="nc bnc" id="L716" title="All 2 branches missed.">                } else if (&quot;edtrshort&quot;.equals(val)) {</span>
<span class="nc" id="L717">                    String s = authshort(entry.getField(&quot;editor&quot;));</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">                    return s == null ? &quot;&quot; : s;</span>
                }
                // authN. First N chars of the first author's last
                // name.
<span class="nc bnc" id="L722" title="All 2 branches missed.">                else if (val.matches(&quot;edtr\\d+&quot;)) {</span>
<span class="nc" id="L723">                    String fa = firstAuthor(entry.getField(&quot;editor&quot;));</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">                    if (fa == null) {</span>
<span class="nc" id="L725">                        return &quot;&quot;;</span>
                    }
<span class="nc" id="L727">                    int num = Integer.parseInt(val.substring(4));</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">                    if (num &gt; fa.length()) {</span>
<span class="nc" id="L729">                        num = fa.length();</span>
                    }
<span class="nc" id="L731">                    return fa.substring(0, num);</span>
                } else {
                    // This &quot;ed&quot; business was a dead end, so just
                    // use it literally:
<span class="nc" id="L735">                    return getField(entry, val);</span>
                }
<span class="nc bnc" id="L737" title="All 2 branches missed.">            } else if (&quot;firstpage&quot;.equals(val)) {</span>
<span class="nc" id="L738">                return firstPage(entry.getField(&quot;pages&quot;));</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">            } else if (&quot;lastpage&quot;.equals(val)) {</span>
<span class="nc" id="L740">                return lastPage(entry.getField(&quot;pages&quot;));</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">            } else if (&quot;shorttitle&quot;.equals(val)) {</span>
<span class="nc" id="L742">                return getTitleWords(3, entry.getField(&quot;title&quot;));</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">            } else if (&quot;veryshorttitle&quot;.equals(val)) {</span>
<span class="nc" id="L744">                return getTitleWords(1, entry.getField(&quot;title&quot;));</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">            } else if (&quot;shortyear&quot;.equals(val)) {</span>
<span class="nc" id="L746">                String ss = entry.getFieldOrAlias(&quot;year&quot;);</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">                if (ss == null) {</span>
<span class="nc" id="L748">                    return &quot;&quot;;</span>
<span class="nc bnc" id="L749" title="All 4 branches missed.">                } else if (ss.startsWith(&quot;in&quot;) || ss.startsWith(&quot;sub&quot;)) {</span>
<span class="nc" id="L750">                    return &quot;IP&quot;;</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">                } else if (ss.length() &gt; 2) {</span>
<span class="nc" id="L752">                    return ss.substring(ss.length() - 2);</span>
                } else {
<span class="nc" id="L754">                    return ss;</span>
                }
<span class="nc bnc" id="L756" title="All 2 branches missed.">            } else if (val.matches(&quot;keyword\\d+&quot;)) {</span>
                // according to LabelPattern.php, it returns keyword number n
<span class="nc" id="L758">                int num = Integer.parseInt(val.substring(7));</span>
<span class="nc" id="L759">                List&lt;String&gt; separatedKeywords = entry.getSeparatedKeywords();</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">                if (separatedKeywords.size() &lt; num) {</span>
                    // not enough keywords
<span class="nc" id="L762">                    return &quot;&quot;;</span>
                } else {
                    // num counts from 1 to n, but index in arrayList count from 0 to n-1
<span class="nc" id="L765">                    return separatedKeywords.get(num-1);</span>
                }
<span class="nc bnc" id="L767" title="All 2 branches missed.">            } else if (val.matches(&quot;keywords\\d*&quot;)) {</span>
                // return all keywords, not separated
                int num;
<span class="nc bnc" id="L770" title="All 2 branches missed.">                if (val.length() &gt; 8) {</span>
<span class="nc" id="L771">                    num = Integer.parseInt(val.substring(8));</span>
<span class="nc" id="L772">                } else {</span>
<span class="nc" id="L773">                    num = Integer.MAX_VALUE;</span>
                }
<span class="nc" id="L775">                List&lt;String&gt; separatedKeywords = entry.getSeparatedKeywords();</span>
<span class="nc" id="L776">                StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">                for (int i = 0; i &lt; Math.min(separatedKeywords.size(), num); i++) {</span>
<span class="nc" id="L778">                    String keyword = separatedKeywords.get(i);</span>
                    // remove all spaces
<span class="nc" id="L780">                    keyword = keyword.replaceAll(&quot;\\s+&quot;, &quot;&quot;);</span>
<span class="nc" id="L781">                    sb.append(keyword);</span>
                }
<span class="nc" id="L783">                return sb.toString();</span>
            } else {
                // we haven't seen any special demands
<span class="nc" id="L786">                return getField(entry, val);</span>
            }
<span class="nc" id="L788">        } catch (NullPointerException ex) {</span>
<span class="nc" id="L789">            LOGGER.debug(&quot;Problem making label&quot;, ex);</span>
<span class="nc" id="L790">            return &quot;&quot;;</span>
        }

    }

    /**
     * Look up a field of a BibEntry, returning its String value, or an
     * empty string if it isn't set.
     * @param entry The entry.
     * @param field The field to look up.
     * @return The field value.
     */
    private static String getField(BibEntry entry, String field) {
<span class="nc" id="L803">        String s = entry.getFieldOrAlias(field);</span>
<span class="nc bnc" id="L804" title="All 2 branches missed.">        return s == null ? &quot;&quot; : s;</span>
    }

    /**
     * Computes an appendix to a BibTeX key that could make it unique. We use
     * a-z for numbers 0-25, and then aa-az, ba-bz, etc.
     *
     * @param number
     *            The appendix number.
     * @return The String to append.
     */
    private static String getAddition(int number) {
<span class="nc bnc" id="L816" title="All 2 branches missed.">        if (number &gt;= CHARS.length()) {</span>
<span class="nc" id="L817">            int lastChar = number % CHARS.length();</span>
<span class="nc" id="L818">            return getAddition((number / CHARS.length()) - 1) + CHARS.substring(lastChar, lastChar + 1);</span>
        } else {
<span class="nc" id="L820">            return CHARS.substring(number, number + 1);</span>
        }
    }

    /**
     * Determines &quot;number&quot; words out of the &quot;title&quot; field in the given BibTeX entry
     */
    public static String getTitleWords(int number, String title) {
<span class="nc" id="L828">        String ss = new RemoveLatexCommands().format(title);</span>
<span class="nc" id="L829">        StringBuilder stringBuilder = new StringBuilder();</span>
        StringBuilder current;
<span class="nc" id="L831">        int piv = 0;</span>
<span class="nc" id="L832">        int words = 0;</span>

        // sorry for being English-centric. I guess these
        // words should really be an editable preference.
<span class="nc bnc" id="L836" title="All 4 branches missed.">        mainl: while ((piv &lt; ss.length()) &amp;&amp; (words &lt; number)) {</span>
<span class="nc" id="L837">            current = new StringBuilder();</span>
            // Get the next word:
<span class="nc bnc" id="L839" title="All 4 branches missed.">            while ((piv &lt; ss.length()) &amp;&amp; !Character.isWhitespace(ss.charAt(piv))</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">                    &amp;&amp; (ss.charAt(piv) != '-')) {</span>
<span class="nc" id="L841">                current.append(ss.charAt(piv));</span>
<span class="nc" id="L842">                piv++;</span>
            }
<span class="nc" id="L844">            piv++;</span>
            // Check if it is ok:
<span class="nc" id="L846">            String word = current.toString().trim();</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">            if (word.isEmpty()) {</span>
<span class="nc" id="L848">                continue;</span>
            }
<span class="nc bnc" id="L850" title="All 2 branches missed.">            for (String smallWord: Word.SMALLER_WORDS) {</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">                if (word.equalsIgnoreCase(smallWord)) {</span>
<span class="nc" id="L852">                    continue mainl;</span>
                }
            }

            // If we get here, the word was accepted.
<span class="nc bnc" id="L857" title="All 2 branches missed.">            if (stringBuilder.length() &gt; 0) {</span>
<span class="nc" id="L858">                stringBuilder.append(' ');</span>
            }
<span class="nc" id="L860">            stringBuilder.append(word);</span>
<span class="nc" id="L861">            words++;</span>
        }

<span class="nc" id="L864">        return keepLettersAndDigitsOnly(stringBuilder.toString());</span>
    }

    private static String keepLettersAndDigitsOnly(String in) {
<span class="nc" id="L868">        StringBuilder stringBuilder = new StringBuilder();</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">        for (int i = 0; i &lt; in.length(); i++) {</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">            if (Character.isLetterOrDigit(in.charAt(i))) {</span>
<span class="nc" id="L871">                stringBuilder.append(in.charAt(i));</span>
            }
        }
<span class="nc" id="L874">        return stringBuilder.toString();</span>
    }


    /**
     * Gets the last name of the first author/editor
     *
     * @param authorField
     *            a &lt;code&gt;String&lt;/code&gt;
     * @return the surname of an author/editor or &quot;&quot; if no author was found
     *    This method is guaranteed to never return null.
     *
     * @throws NullPointerException
     *             if authorField == null
     */
    public static String firstAuthor(String authorField) {
<span class="nc" id="L890">        AuthorList authorList = AuthorList.parse(authorField);</span>
<span class="nc bnc" id="L891" title="All 2 branches missed.">        if (authorList.isEmpty()) {</span>
<span class="nc" id="L892">            return &quot;&quot;;</span>
        }
<span class="nc" id="L894">        String s = authorList.getAuthor(0).getLast();</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">        return s == null ? &quot;&quot; : s;</span>

    }

    /**
     * Gets the first name initials of the first author/editor
     *
     * @param authorField
     *            a &lt;code&gt;String&lt;/code&gt;
     * @return the first name initial of an author/editor or &quot;&quot; if no author was found
     *    This method is guaranteed to never return null.
     *
     * @throws NullPointerException
     *             if authorField == null
     */
    public static String firstAuthorForenameInitials(String authorField) {
<span class="nc" id="L911">        AuthorList authorList = AuthorList.parse(authorField);</span>
<span class="nc bnc" id="L912" title="All 2 branches missed.">        if (authorList.isEmpty()) {</span>
<span class="nc" id="L913">            return &quot;&quot;;</span>
        }
<span class="nc" id="L915">        String s = authorList.getAuthor(0).getFirstAbbr();</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">        return s == null ? &quot;&quot; : s.substring(0, 1);</span>
    }

    /**
     * Gets the von part and the last name of the first author/editor
     * No spaces are returned
     *
     * @param authorField
     *            a &lt;code&gt;String&lt;/code&gt;
     * @return the von part and surname of an author/editor or &quot;&quot; if no author was found.
     *  This method is guaranteed to never return null.
     *
     * @throws NullPointerException
     *             if authorField == null
     */
    public static String firstAuthorVonAndLast(String authorField) {
<span class="nc" id="L932">        AuthorList authorList = AuthorList.parse(authorField);</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">        if (authorList.isEmpty()) {</span>
<span class="nc" id="L934">            return &quot;&quot;;</span>
        }
<span class="nc" id="L936">        String vonAuthor = authorList.getAuthor(0).getVon().replaceAll(&quot; &quot;, &quot;&quot;);</span>
<span class="nc" id="L937">        StringBuilder stringBuilder = new StringBuilder();</span>
<span class="nc bnc" id="L938" title="All 2 branches missed.">        if (vonAuthor != null) {</span>
<span class="nc" id="L939">            stringBuilder.append(vonAuthor);</span>
        }
<span class="nc" id="L941">        vonAuthor = authorList.getAuthor(0).getLast();</span>
<span class="nc bnc" id="L942" title="All 2 branches missed.">        if (vonAuthor != null) {</span>
<span class="nc" id="L943">            stringBuilder.append(vonAuthor);</span>
        }
<span class="nc" id="L945">        return stringBuilder.toString();</span>
    }

    /**
     * Gets the last name of the last author/editor
     * @param authorField a &lt;code&gt;String&lt;/code&gt;
     * @return the surname of an author/editor
     */
    public static String lastAuthor(String authorField) {
<span class="nc" id="L954">        String[] tokens = AuthorList.fixAuthorForAlphabetization(authorField).split(&quot;\\s+\\band\\b\\s+&quot;);</span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">        if (tokens.length &gt; 0) {</span>
<span class="nc" id="L956">            String[] lastAuthor = tokens[tokens.length - 1].split(&quot;,&quot;);</span>
<span class="nc" id="L957">            return lastAuthor[0];</span>
        } else {
            // if author is empty
<span class="nc" id="L960">            return &quot;&quot;;</span>
        }
    }

    /**
     * Gets the forename initials of the last author/editor
     *
     * @param authorField
     *            a &lt;code&gt;String&lt;/code&gt;
     * @return the forename initial of an author/editor or &quot;&quot; if no author was found
     *    This method is guaranteed to never return null.
     *
     * @throws NullPointerException
     *             if authorField == null
     */
    public static String lastAuthorForenameInitials(String authorField) {
<span class="nc" id="L976">        AuthorList authorList = AuthorList.parse(authorField);</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">        if (authorList.isEmpty()) {</span>
<span class="nc" id="L978">            return &quot;&quot;;</span>
        }
<span class="nc" id="L980">        String s = authorList.getAuthor(authorList.getNumberOfAuthors() - 1).getFirstAbbr();</span>
<span class="nc bnc" id="L981" title="All 2 branches missed.">        return s == null ? &quot;&quot; : s.substring(0, 1);</span>
    }

    /**
     * Gets the last name of all authors/editors
     * @param authorField a &lt;code&gt;String&lt;/code&gt;
     * @return the sur name of all authors/editors
     */
    public static String allAuthors(String authorField) {
        // Quick hack to use NAuthors to avoid code duplication
<span class="nc" id="L991">        return nAuthors(authorField, Integer.MAX_VALUE);</span>
    }

    /**
     * Returns the authors according to the BibTeX-alpha-Style
     * @param authorField string containing the value of the author field
     * @return the initials of all authornames
     */
    public static String authorsAlpha(String authorField) {
<span class="nc" id="L1000">        String authors = &quot;&quot;;</span>

<span class="nc" id="L1002">        String fixedAuthors = AuthorList.fixAuthorLastNameOnlyCommas(authorField, false);</span>

        // drop the &quot;and&quot; before the last author
        // -&gt; makes processing easier
<span class="nc" id="L1006">        fixedAuthors = fixedAuthors.replace(&quot; and &quot;, &quot;, &quot;);</span>

<span class="nc" id="L1008">        String[] tokens = fixedAuthors.split(&quot;,&quot;);</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">        int max = tokens.length &gt; 4 ? 3 : tokens.length;</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">        if (max == 1) {</span>
<span class="nc" id="L1011">            String[] firstAuthor = tokens[0].replaceAll(&quot;\\s+&quot;, &quot; &quot;).trim().split(&quot; &quot;);</span>
            // take first letter of any &quot;prefixes&quot; (e.g. van der Aalst -&gt; vd)
<span class="nc bnc" id="L1013" title="All 2 branches missed.">            for (int j = 0; j &lt; (firstAuthor.length - 1); j++) {</span>
<span class="nc" id="L1014">                authors = authors.concat(firstAuthor[j].substring(0, 1));</span>
            }
            // append last part of last name completely
<span class="nc" id="L1017">            authors = authors.concat(firstAuthor[firstAuthor.length - 1].substring(0,</span>
<span class="nc" id="L1018">                    Math.min(3, firstAuthor[firstAuthor.length - 1].length())));</span>
<span class="nc" id="L1019">        } else {</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">            for (int i = 0; i &lt; max; i++) {</span>
                // replace all whitespaces by &quot; &quot;
                // split the lastname at &quot; &quot;
<span class="nc" id="L1023">                String[] curAuthor = tokens[i].replaceAll(&quot;\\s+&quot;, &quot; &quot;).trim().split(&quot; &quot;);</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">                for (String aCurAuthor : curAuthor) {</span>
                    // use first character of each part of lastname
<span class="nc" id="L1026">                    authors = authors.concat(aCurAuthor.substring(0, 1));</span>
                }
            }
<span class="nc bnc" id="L1029" title="All 2 branches missed.">            if (tokens.length &gt; 4) {</span>
<span class="nc" id="L1030">                authors = authors.concat(&quot;+&quot;);</span>
            }
        }
<span class="nc" id="L1033">        return authors;</span>
    }

    /**
     * Gets the surnames of the first N authors and appends EtAl if there are more than N authors
     * @param authorField a &lt;code&gt;String&lt;/code&gt;
     * @param n the number of desired authors
     * @return Gets the surnames of the first N authors and appends EtAl if there are more than N authors
     */
    public static String nAuthors(String authorField, int n) {
<span class="nc" id="L1043">        String[] tokens = AuthorList.fixAuthorForAlphabetization(authorField).split(&quot;\\s+\\band\\b\\s+&quot;);</span>
<span class="nc" id="L1044">        int i = 0;</span>
<span class="nc" id="L1045">        StringBuilder authorSB = new StringBuilder();</span>
<span class="nc bnc" id="L1046" title="All 4 branches missed.">        while ((tokens.length &gt; i) &amp;&amp; (i &lt; n)) {</span>
<span class="nc" id="L1047">            String lastName = tokens[i].replaceAll(&quot;,\\s+.*&quot;, &quot;&quot;);</span>
<span class="nc" id="L1048">            authorSB.append(lastName);</span>
<span class="nc" id="L1049">            i++;</span>
        }
<span class="nc bnc" id="L1051" title="All 2 branches missed.">        if (tokens.length &gt; n) {</span>
<span class="nc" id="L1052">            authorSB.append(&quot;EtAl&quot;);</span>
        }
<span class="nc" id="L1054">        return authorSB.toString();</span>
    }

    /**
     * Gets the first part of the last name of the first
     * author/editor, and appends the last name initial of the
     * remaining authors/editors.
     * Maximum 5 characters
     * @param authorField a &lt;code&gt;String&lt;/code&gt;
     * @return the surname of all authors/editors
     */
    public static String oneAuthorPlusIni(String authorField) {
<span class="nc" id="L1066">        String fixedAuthorField = AuthorList.fixAuthorForAlphabetization(authorField);</span>
<span class="nc" id="L1067">        String[] tokens = fixedAuthorField.split(&quot;\\s+\\band\\b\\s+&quot;);</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">        if (tokens.length == 0) {</span>
<span class="nc" id="L1069">            return &quot;&quot;;</span>
        }

<span class="nc" id="L1072">        String firstAuthor = tokens[0].split(&quot;,&quot;)[0];</span>
<span class="nc" id="L1073">        StringBuilder authorSB = new StringBuilder();</span>
<span class="nc" id="L1074">        authorSB.append(firstAuthor.substring(0, Math.min(CHARS_OF_FIRST, firstAuthor.length())));</span>
<span class="nc" id="L1075">        int i = 1;</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">        while (tokens.length &gt; i) {</span>
            // convert lastname, firstname to firstname lastname
<span class="nc" id="L1078">            authorSB.append(tokens[i].charAt(0));</span>
<span class="nc" id="L1079">            i++;</span>
        }
<span class="nc" id="L1081">        return authorSB.toString();</span>
    }

    /**
     * auth.auth.ea format:
     * Isaac Newton and James Maxwell and Albert Einstein (1960)
     * Isaac Newton and James Maxwell (1960)
     *  give:
     * Newton.Maxwell.ea
     * Newton.Maxwell
     */
    public static String authAuthEa(String authorField) {
<span class="nc" id="L1093">        String fixedAuthorField = AuthorList.fixAuthorForAlphabetization(authorField);</span>

<span class="nc" id="L1095">        String[] tokens = fixedAuthorField.split(&quot;\\s+\\band\\b\\s+&quot;);</span>
<span class="nc bnc" id="L1096" title="All 2 branches missed.">        if (tokens.length == 0) {</span>
<span class="nc" id="L1097">            return &quot;&quot;;</span>
        }

<span class="nc" id="L1100">        StringBuilder author = new StringBuilder();</span>
        // append first author
<span class="nc" id="L1102">        author.append((tokens[0].split(&quot;,&quot;))[0]);</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">        if (tokens.length &gt;= 2) {</span>
            // append second author
<span class="nc" id="L1105">            author.append('.').append((tokens[1].split(&quot;,&quot;))[0]);</span>
        }
<span class="nc bnc" id="L1107" title="All 2 branches missed.">        if (tokens.length &gt; 2) {</span>
            // append &quot;.ea&quot; if more than 2 authors
<span class="nc" id="L1109">            author.append(&quot;.ea&quot;);</span>
        }

<span class="nc" id="L1112">        return author.toString();</span>
    }

    /**
     * auth.etal, authEtAl, ... format:
     * Isaac Newton and James Maxwell and Albert Einstein (1960)
     * Isaac Newton and James Maxwell (1960)
     *
     *  auth.etal give (delim=&quot;.&quot;, append=&quot;.etal&quot;):
     * Newton.etal
     * Newton.Maxwell
     *
     *  authEtAl give (delim=&quot;&quot;, append=&quot;EtAl&quot;):
     * NewtonEtAl
     * NewtonMaxwell
     *
     * Note that [authEtAl] equals [authors2]
     */
    public static String authEtal(String authorField, String delim,
            String append) {
<span class="nc" id="L1132">        String fixedAuthorField = AuthorList.fixAuthorForAlphabetization(authorField);</span>

<span class="nc" id="L1134">        String[] tokens = fixedAuthorField.split(&quot;\\s*\\band\\b\\s*&quot;);</span>
<span class="nc bnc" id="L1135" title="All 2 branches missed.">        if (tokens.length == 0) {</span>
<span class="nc" id="L1136">            return &quot;&quot;;</span>
        }
<span class="nc" id="L1138">        StringBuilder author = new StringBuilder();</span>
<span class="nc" id="L1139">        author.append((tokens[0].split(&quot;,&quot;))[0]);</span>
<span class="nc bnc" id="L1140" title="All 2 branches missed.">        if (tokens.length == 2) {</span>
<span class="nc" id="L1141">            author.append(delim).append((tokens[1].split(&quot;,&quot;))[0]);</span>
<span class="nc bnc" id="L1142" title="All 2 branches missed.">        } else if (tokens.length &gt; 2) {</span>
<span class="nc" id="L1143">            author.append(append);</span>
        }

<span class="nc" id="L1146">        return author.toString();</span>
    }

    /**
     * The first N characters of the Mth author/editor.
     * M starts counting from 1
     */
    public static String authNofMth(String authorField, int n, int m) {
        // have m counting from 0
<span class="nc" id="L1155">        int mminusone = m - 1;</span>

<span class="nc" id="L1157">        String fixedAuthorField = AuthorList.fixAuthorForAlphabetization(authorField);</span>

<span class="nc" id="L1159">        String[] tokens = fixedAuthorField.split(&quot;\\s+\\band\\b\\s+&quot;);</span>
<span class="nc bnc" id="L1160" title="All 6 branches missed.">        if ((tokens.length &lt;= mminusone) || (n &lt; 0) || (mminusone &lt; 0)) {</span>
<span class="nc" id="L1161">            return &quot;&quot;;</span>
        }
<span class="nc" id="L1163">        String lastName = (tokens[mminusone].split(&quot;,&quot;))[0];</span>
<span class="nc bnc" id="L1164" title="All 2 branches missed.">        if (lastName.length() &lt;= n) {</span>
<span class="nc" id="L1165">            return lastName;</span>
        } else {
<span class="nc" id="L1167">            return lastName.substring(0, n);</span>
        }
    }

    /**
     * authshort format:
     * added by Kolja Brix, kbx@users.sourceforge.net
     *
     * given author names
     *
     *   Isaac Newton and James Maxwell and Albert Einstein and N. Bohr
     *
     *   Isaac Newton and James Maxwell and Albert Einstein
     *
     *   Isaac Newton and James Maxwell
     *
     *   Isaac Newton
     *
     * yield
     *
     *   NME+
     *
     *   NME
     *
     *   NM
     *
     *   Newton
     */
    public static String authshort(String authorField) {
<span class="nc" id="L1196">        String fixedAuthorField = AuthorList.fixAuthorForAlphabetization(authorField);</span>
<span class="nc" id="L1197">        StringBuilder author = new StringBuilder();</span>
<span class="nc" id="L1198">        String[] tokens = fixedAuthorField.split(&quot;\\band\\b&quot;);</span>
<span class="nc" id="L1199">        int i = 0;</span>

<span class="nc bnc" id="L1201" title="All 2 branches missed.">        if (tokens.length == 1) {</span>
<span class="nc" id="L1202">            author.append(authNofMth(fixedAuthorField, fixedAuthorField.length(), 1));</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">        } else if (tokens.length &gt;= 2) {</span>
<span class="nc bnc" id="L1204" title="All 4 branches missed.">            while ((tokens.length &gt; i) &amp;&amp; (i &lt; 3)) {</span>
<span class="nc" id="L1205">                author.append(authNofMth(fixedAuthorField, 1, i + 1));</span>
<span class="nc" id="L1206">                i++;</span>
            }
<span class="nc bnc" id="L1208" title="All 2 branches missed.">            if (tokens.length &gt; 3) {</span>
<span class="nc" id="L1209">                author.append('+');</span>
            }
        }

<span class="nc" id="L1213">        return author.toString();</span>
    }

    /**
     * authIniN format:
     *
     * Each author gets (N div #authors) chars, the remaining (N mod #authors)
     * chars are equally distributed to the authors first in the row.
     *
     * If (N &lt; #authors), only the first N authors get mentioned.
     *
     * For example if
     *
     * a) I. Newton and J. Maxwell and A. Einstein and N. Bohr (..)
     *
     * b) I. Newton and J. Maxwell and A. Einstein
     *
     * c) I. Newton and J. Maxwell
     *
     * d) I. Newton
     *
     * authIni4 gives: a) NMEB, b) NeME, c) NeMa, d) Newt
     *
     * @param authorField
     *            The authors to format.
     *
     * @param n
     *            The maximum number of characters this string will be long. A
     *            negative number or zero will lead to &quot;&quot; be returned.
     *
     * @throws NullPointerException
     *             if authorField is null and n &gt; 0
     */
    public static String authIniN(String authorField, int n) {

<span class="nc bnc" id="L1248" title="All 2 branches missed.">        if (n &lt;= 0) {</span>
<span class="nc" id="L1249">            return &quot;&quot;;</span>
        }

<span class="nc" id="L1252">        String fixedAuthorField = AuthorList.fixAuthorForAlphabetization(authorField);</span>
<span class="nc" id="L1253">        StringBuilder author = new StringBuilder();</span>
<span class="nc" id="L1254">        String[] tokens = fixedAuthorField.split(&quot;\\band\\b&quot;);</span>

<span class="nc bnc" id="L1256" title="All 2 branches missed.">        if (tokens.length == 0) {</span>
<span class="nc" id="L1257">            return author.toString();</span>
        }

<span class="nc" id="L1260">        int i = 0;</span>
<span class="nc" id="L1261">        int charsAll = n / tokens.length;</span>
<span class="nc bnc" id="L1262" title="All 2 branches missed.">        while (tokens.length &gt; i) {</span>
<span class="nc bnc" id="L1263" title="All 2 branches missed.">            if (i &lt; (n % tokens.length)) {</span>
<span class="nc" id="L1264">                author.append(authNofMth(fixedAuthorField, charsAll + 1, i + 1));</span>
<span class="nc" id="L1265">            } else {</span>
<span class="nc" id="L1266">                author.append(authNofMth(fixedAuthorField, charsAll, i + 1));</span>
            }
<span class="nc" id="L1268">            i++;</span>
        }

<span class="nc bnc" id="L1271" title="All 2 branches missed.">        if (author.length() &lt;= n) {</span>
<span class="nc" id="L1272">            return author.toString();</span>
        } else {
<span class="nc" id="L1274">            return author.toString().substring(0, n);</span>
        }
    }

    /**
     * Split the pages field into separate numbers and return the lowest
     *
     * @param pages
     *            (may not be null) a pages string such as 42--111 or
     *            7,41,73--97 or 43+
     *
     * @return the first page number or &quot;&quot; if no number is found in the string
     *
     * @throws NullPointerException
     *             if pages is null
     */
    public static String firstPage(String pages) {
<span class="nc" id="L1291">        final String[] splitPages = pages.split(&quot;\\D+&quot;);</span>
<span class="nc" id="L1292">        int result = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L1293" title="All 2 branches missed.">        for (String n : splitPages) {</span>
<span class="nc bnc" id="L1294" title="All 2 branches missed.">            if (n.matches(&quot;\\d+&quot;)) {</span>
<span class="nc" id="L1295">                result = Math.min(Integer.parseInt(n), result);</span>
            }
        }

<span class="nc bnc" id="L1299" title="All 2 branches missed.">        if (result == Integer.MAX_VALUE) {</span>
<span class="nc" id="L1300">            return &quot;&quot;;</span>
        } else {
<span class="nc" id="L1302">            return String.valueOf(result);</span>
        }
    }

    /**
     * Split the pages field into separate numbers and return the highest
     *
     * @param pages
     *            a pages string such as 42--111 or 7,41,73--97 or 43+
     *
     * @return the first page number or &quot;&quot; if no number is found in the string
     *
     * @throws NullPointerException
     *             if pages is null.
     */
    public static String lastPage(String pages) {
<span class="nc" id="L1318">        final String[] splitPages = pages.split(&quot;\\D+&quot;);</span>
<span class="nc" id="L1319">        int result = Integer.MIN_VALUE;</span>
<span class="nc bnc" id="L1320" title="All 2 branches missed.">        for (String n : splitPages) {</span>
<span class="nc bnc" id="L1321" title="All 2 branches missed.">            if (n.matches(&quot;\\d+&quot;)) {</span>
<span class="nc" id="L1322">                result = Math.max(Integer.parseInt(n), result);</span>
            }
        }

<span class="nc bnc" id="L1326" title="All 2 branches missed.">        if (result == Integer.MIN_VALUE) {</span>
<span class="nc" id="L1327">            return &quot;&quot;;</span>
        } else {
<span class="nc" id="L1329">            return String.valueOf(result);</span>
        }
    }

    /**
     * Parse a field marker with modifiers, possibly containing a parenthesised modifier,
     * as well as escaped colons and parentheses.
     * @param arg The argument string.
     * @return An array of strings representing the parts of the marker
     */
    private static String[] parseFieldMarker(String arg) {
<span class="nc" id="L1340">        List&lt;String&gt; parts = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1341">        StringBuilder current = new StringBuilder();</span>
<span class="nc" id="L1342">        boolean escaped = false;</span>
<span class="nc" id="L1343">        int inParenthesis = 0;</span>
<span class="nc bnc" id="L1344" title="All 2 branches missed.">        for (int i = 0; i &lt; arg.length(); i++) {</span>
<span class="nc bnc" id="L1345" title="All 6 branches missed.">            if ((arg.charAt(i) == ':') &amp;&amp; !escaped &amp;&amp; (inParenthesis == 0)) {</span>
<span class="nc" id="L1346">                parts.add(current.toString());</span>
<span class="nc" id="L1347">                current = new StringBuilder();</span>
<span class="nc bnc" id="L1348" title="All 4 branches missed.">            } else if ((arg.charAt(i) == '(') &amp;&amp; !escaped) {</span>
<span class="nc" id="L1349">                inParenthesis++;</span>
<span class="nc" id="L1350">                current.append(arg.charAt(i));</span>
<span class="nc bnc" id="L1351" title="All 6 branches missed.">            } else if ((arg.charAt(i) == ')') &amp;&amp; !escaped &amp;&amp; (inParenthesis &gt; 0)) {</span>
<span class="nc" id="L1352">                inParenthesis--;</span>
<span class="nc" id="L1353">                current.append(arg.charAt(i));</span>
<span class="nc bnc" id="L1354" title="All 2 branches missed.">            } else if (arg.charAt(i) == '\\') {</span>
<span class="nc bnc" id="L1355" title="All 2 branches missed.">                if (escaped) {</span>
<span class="nc" id="L1356">                    escaped = false;</span>
<span class="nc" id="L1357">                    current.append(arg.charAt(i));</span>
<span class="nc" id="L1358">                } else {</span>
<span class="nc" id="L1359">                    escaped = true;</span>
                }
<span class="nc bnc" id="L1361" title="All 2 branches missed.">            } else if (escaped) {</span>
<span class="nc" id="L1362">                current.append(arg.charAt(i));</span>
<span class="nc" id="L1363">                escaped = false;</span>
<span class="nc" id="L1364">            } else {</span>
<span class="nc" id="L1365">                current.append(arg.charAt(i));</span>
            }
        }
<span class="nc" id="L1368">        parts.add(current.toString());</span>
<span class="nc" id="L1369">        return parts.toArray(new String[parts.size()]);</span>
    }

    /**
     * This method returns a String similar to the one passed in, except that it is molded into a form that is
     * acceptable for bibtex.
     * &lt;p&gt;
     * Watch-out that the returned string might be of length 0 afterwards.
     *
     * @param key mayBeNull
     */
    public static String checkLegalKey(String key) {
<span class="fc bfc" id="L1381" title="All 2 branches covered.">        if (key == null) {</span>
<span class="fc" id="L1382">            return null;</span>
        }
<span class="fc" id="L1384">        return checkLegalKey(key,</span>
<span class="fc" id="L1385">                JabRefPreferences.getInstance().getBoolean(JabRefPreferences.ENFORCE_LEGAL_BIBTEX_KEY));</span>
    }

    /**
     * This method returns a String similar to the one passed in, except that it is molded into a form that is
     * acceptable for bibtex.
     * &lt;p&gt;
     * Watch-out that the returned string might be of length 0 afterwards.
     *
     * @param key             mayBeNull
     * @param enforceLegalKey make sure that the key is legal in all respects
     */
    public static String checkLegalKey(String key, boolean enforceLegalKey) {//TODO cheacegem da chave Bib
<span class="pc bpc" id="L1398" title="1 of 2 branches missed.">        if (key == null) {</span>
<span class="nc" id="L1399">            return null;</span>
        }
<span class="pc bpc" id="L1401" title="1 of 2 branches missed.">        if (!enforceLegalKey) {</span>
            // User doesn't want us to enforce legal characters. We must still look
            // for whitespace and some characters such as commas, since these would
            // interfere with parsing:
<span class="nc" id="L1405">            StringBuilder newKey = new StringBuilder();</span>
<span class="nc bnc" id="L1406" title="All 2 branches missed.">            for (int i = 0; i &lt; key.length(); i++) {</span>
<span class="nc" id="L1407">                char c = key.charAt(i);</span>
<span class="nc bnc" id="L1408" title="All 4 branches missed.">                if (!Character.isWhitespace(c) &amp;&amp; (&quot;{}(),\\\&quot;&quot;.indexOf(c) == -1)) {</span>
<span class="nc" id="L1409">                    newKey.append(c);</span>
                }
            }
<span class="nc" id="L1412">            return newKey.toString();</span>
        }

<span class="fc" id="L1415">        StringBuilder newKey = new StringBuilder();</span>
<span class="fc bfc" id="L1416" title="All 2 branches covered.">        for (int i = 0; i &lt; key.length(); i++) {</span>
<span class="fc" id="L1417">            char c = key.charAt(i);</span>
<span class="pc bpc" id="L1418" title="1 of 4 branches missed.">            if (!Character.isWhitespace(c) &amp;&amp; (&quot;{}(),\\\&quot;#~^'&quot;.indexOf(c) == -1)) {</span>
<span class="fc" id="L1419">                newKey.append(c);</span>
            }
        }
<span class="fc" id="L1422">        StringBuilder newKey2 = new StringBuilder();</span>
<span class="fc bfc" id="L1423" title="All 2 branches covered.">        if (newKey.length() &lt; 2) {</span>
<span class="fc" id="L1424">            Random r = new Random();</span>
<span class="fc" id="L1425">            char c = (char) (r.nextInt(26) + 'a');</span>
<span class="fc" id="L1426">            newKey2.append(Character.toUpperCase(c));</span>
<span class="fc" id="L1427">            newKey2.append(c);</span>
<span class="fc" id="L1428">        } else {</span>
<span class="fc bfc" id="L1429" title="All 2 branches covered.">            if (Character.isDigit(newKey.charAt(0))) {</span>
<span class="fc" id="L1430">                Random r = new Random();</span>
<span class="fc" id="L1431">                char c = (char) (r.nextInt(26) + 'a');</span>
<span class="fc" id="L1432">                newKey2.append(Character.toUpperCase(c));</span>
<span class="fc" id="L1433">                newKey2.append(c);</span>
<span class="fc" id="L1434">            } else {</span>
<span class="fc" id="L1435">                newKey2.append(newKey.toString());</span>
            }

        }

<span class="fc" id="L1440">        System.out.println(newKey2.toString());</span>

        // Replace non-English characters like umlauts etc. with a sensible
        // letter or letter combination that bibtex can accept.

<span class="fc" id="L1445">        return StringUtil.replaceSpecialCharacters(newKey2.toString());</span>
    }

    public static List&lt;String&gt; getDefaultLabelPattern() {
<span class="nc" id="L1449">        return defaultLabelPattern;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span>JabRefMain (11 de nov. de 2021 10:55:25)</div></body></html>